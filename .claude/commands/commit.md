---
description: Analyze changes, create coherent commit(s), and sync to deciduous
allowed-tools: Bash(git:*, deciduous:*)
argument-hint: [commit message]
---

# Smart Commit

Analyzes staged/unstaged changes, ensures commit coherence, and syncs to deciduous.

## Step 1: Analyze Changes

```bash
# Check what's staged and unstaged
git status

# Get the full diff
git diff --stat
git diff --staged --stat

# See recent commits for message style
git log --oneline -5
```

## Step 2: Coherence Check

Review the diff and categorize changes:

1. **Group by logical unit** - Which files belong together?
2. **Identify themes** - feat, fix, refactor, chore, docs, test, style
3. **Check for mixing** - Are there unrelated changes lumped together?

### Coherence Rules

| Situation | Action |
|-----------|--------|
| All changes relate to one feature/fix | Single commit |
| Mix of feature + unrelated refactor | Split: commit feature first, then refactor |
| Mix of feature + its tests | Single commit (tests belong with feature) |
| Mix of multiple unrelated fixes | Split into separate commits |
| Lots of overlapping changes across themes | **WARN** - ask user how to proceed |

### Warning Signs (ASK USER)

- Same file touched for multiple unrelated reasons
- More than 3 distinct themes in one diff
- Large refactor mixed with small feature
- Debug code mixed with production changes

## Step 3: Propose Commit(s)

Based on analysis, propose ONE of:

**A) Single coherent commit:**
```
Ready to commit all changes as:
  "<type>: <message>"

Files: <list>
```

**B) Split commits:**
```
These changes should be split:

Commit 1: "<type>: <message>"
  - file1.ts
  - file2.ts

Commit 2: "<type>: <message>"
  - file3.ts

Proceed with split? (I'll stage and commit each separately)
```

**C) Warning - overlapping work:**
```
⚠️  These changes have overlapping concerns:
  - file1.ts: both refactor AND new feature
  - file2.ts: fix AND unrelated cleanup

Options:
  1. Commit together as "<message>" (not ideal)
  2. I can try to split by hunks (git add -p)
  3. You manually stage what you want

How should I proceed?
```

## Step 4: Execute Commit(s)

For each commit:

```bash
# Stage files (or use git add -p for splits)
git add <files>

# Commit WITHOUT Claude signature
git commit -m "<type>: <message>"
```

**CRITICAL: No Claude signature.** Just the commit message, nothing else.

## Step 5: Deciduous Integration

After EACH commit:

```bash
# Find the current action node (most recent action in graph)
deciduous nodes | grep action | tail -1

# Create outcome linked to commit
deciduous add outcome "Committed: <commit message>" -c 95 --commit HEAD

# Link outcome to action
deciduous link <action_id> <outcome_id> -r "Committed"

# Sync graph
deciduous sync
```

## Step 6: Summary

After all commits:

```
✓ Created N commit(s):
  - abc1234: feat: add dark mode toggle
  - def5678: refactor: extract theme utils

✓ Deciduous synced:
  - Outcome nodes linked to commits
  - Graph exported to docs/

Push when ready: git push
```

## Commit Message Format

```
<type>: <short description>

[optional body explaining why, not what]
```

Types: `feat`, `fix`, `refactor`, `chore`, `docs`, `test`, `style`

**NO Claude signature. NO "Generated by". Just the message.**

## Quick Single Commit

If $ARGUMENTS provided and changes are coherent:

```bash
git add -A
git commit -m "$ARGUMENTS"
deciduous add outcome "Committed: $ARGUMENTS" -c 95 --commit HEAD
deciduous link <action_id> <outcome_id> -r "Committed"
deciduous sync
```
